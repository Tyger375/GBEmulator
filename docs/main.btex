@class article\

@latex {
    \usepackage{multirow}
    \usepackage{xspace}
    \usepackage{textcomp}
    \usepackage{array}
    \usepackage{booktabs}
    \usepackage[export]{adjustbox}[2011/08/13]
}

@title Emulation\
@author Takanen Edoardo\

@document {
    @maketitle\

    @center {
        @LARGE\ Abstract
    }

    **MOVE TO CARTRIDGE SECTION**
    \\
    Another interesting fact I found out when making this emulator is what is inside a cartridge.
    It is fascinating to know that some cartridges would not only include the ROM banks with the game code, but they could also supply their own additional SRAM (Static Random-Access Memory), as well as a battery to preserve the game saves.
    Due to limiting memory sizes, games could also have a Memory Bank Controller (MBC) to change what ROM should be pointed for memory region $4000-7FFF$.
    \\
    Notice that all these additional components are **not** supported on my emulator, since the original Tetris DMG cartridge just had a 32 Kb ROM.
    \\

    (still to be placed)
    \\
    images from:
    @list {
        @item {
            https://www.pastraiser.com/cpu/gameboy/gameboy_opcodes.html
        }
    }
    
    @newpage\

    @tableofcontents\
    @newpage\

    @section (label=sec:introduction) Introduction\
    As a kid, I used to play with some Nintendo (copyright symbol) consoles like the Wii or the DS and I've always been keen about the games they make.
    This passion for videogames grew on me so that I got interested in the making process of them, leading to game development.
    I never asked myself one question, though, until this year, which is how are these games able to run onto this consoles? and how can people
    make emulators so that I could play on my personal computer?
    Thus, I decided to embrace the unknown world of emulation, because I have always been fascinated by it but always took it for granted.
    \\
    Emulation is not well explained on the Internet.
    Mainly, the results you will find if you search for it are "the program pretends to be the console" or "you will be able to play old titles".
    Unfortunately I was not satisfied with these responses and I wanted to know more. Thus, my emulation journey started with looking for a full definition of this process.
    \\
    I will try to give my own definition of emulation, so that I can lay a starting point to a general knowledge that will be then deepened during the paper.
    With this being said, to "make an emulator" means to develop the software that will do exactly what the hardware of the console does, so that when plugging the game data,
    the program will know how to read and handle it. \\
    Emulation can only happen when the machine in which we run the software is more powerful than the hardware we want to emulate.
    For example, if our console has 2Kb of memory, for sure we are not able to emulate it on a computer that has 2Kb or less, since we also have to consider that
    the host computer will have an operating system running (which uses some of the RAM).
    I chose to make a Game Boy emulator, because while looking for the retro consoles, it seemed the least difficult when talking about the hardware structure complexity,
    meaning a good way to start tackling this topic.
    @newpage\

    @section (label=sec:premises) Premises\
    This emulator project is purely for understanding the concepts and the theory about how a machine like a console (or similarly a computer) is made (and also for fun).
    There are many better-developed Game Boy emulators online, and making one that could compete with the other popular ones is nowhere near my goals.
    In addition, I could not achieve the level of knowledge I want to reach if I just looked at other people's codes, I wanted to **fully** understand the subject.
    Obviously though I have to start somewhere, I do not have the skills to reverse-engineer a real Game Boy (although it would be an extremely interesting challenge),
    for this reason I will only consult theory guides made by many passionate developers and hackers that already did the work of studying the Game Boy from scratch for us.
    For a better understanding, I used **two** sources for this project, in order to have a dual perspective on the study.\\
    For anyone who would like to dig into this challenge too, the guides are @href https://gbdev.io/ GBDev\$$fs$$ and @href https://hacktix.github.io/GBEDG/ GBEDG\.
    \\
    **What this paper is not?** \\
    This paper is not and was not intended as a guide, I previously attached some real references.
    This document is a report of my journey throughtout the development of the emulator, made to understand the fundamentals of what is around us, from personal computers 
    to smartphones. It could also be a way for readers to get passionate about this topic and an inspiration for them to make their own emulators 
    (or even better, their own consoles!).
    @newpage\
    
    @section (label=sec:general-structure) General Structure\
    The first thing I want to cover is in what way we want to structure our emulator.

    @code (language=C++, label=lst:general-structure) ./code/general-structure.code\

    Actually, when we look at the circuit inside the Game Boy, all the components are, on one side, all on their own, they all execute at the same time.
    The CPU could be executing a simple addition, while the PPU could be rendering graphics onto the screen, all of these things happen simultaneously.
    This **can** be done with software, but would mean more complexity. Hence we will pick a less complicated path, and decide to execute the components one at a time.

    @code (language=C++, label=lst:clocking) ./code/clocking.code\ 

    The real hardware is driven by the clock, while my implementation will be driven by how many clock cycles an instruction took.
    This may cause some bugs and imprecisions in the emulator (and that was my main concern), but in the end it worked just fine.
    @newpage\

    @section (label=sec:memory) Memory\
    Before looking at the main components that shape the Game Boy hardware, I would like to focus on how memory is subdivided inside the console.\\

    @subsection (label=subsec:memory-mapping) Memory mapping\
    The address bus had 16 bits, meaning there could be 65'536 unique addresses (64Kb). \\
    Since the Game Boy did not have a flash memory, those 64Kb were all the console could access 
    (this includes all the different RAMs, the cartridge data, and the registers made to control various components).
    Internally inside the Game Boy, there is some logic that specifies what component will be activated 
    based on the requesting address, but we do not have to worry about it since we are not dealing with actual hardware this time.
    \\
    These are the regions into which the memory is split, along with a brief description of their use.
    Notice that some areas are marked as "Prohibited", though Nintendo has not provided an explanation for this.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ ||c | c | c|| }
            \toprule
            Start & End & Description \\
            \midrule
            0000 & 3FFF & 16Kb cartridge ROM \\
            4000 & 7FFF & 16Kb cartridge ROM\textsuperscript{*} \\
            8000 & 9FFF & 8Kb VRAM \\
            A000 & BFFF & 8Kb External RAM \\
            C000 & CFFF & 4Kb Work RAM \\
            D000 & DFFF & 4Kb Work RAM \\
            E000 & FDFF & Prohibited area \\
            FE00 & FE9F & OAM \\
            FEA0 & FEFF & Prohibited area \\
            FF00 & FF7F & I/O Registers \\
            FF80 & FFFE & High RAM \\
            FFFF & FFFF & IE register \\
            \midrule

            \addlinespace[1ex]
            \multicolumn{3}{l}{\textsuperscript{*}switchable}
        \end{tabular}
        \caption{Game Boy's memory mapping}
        \end{table}
    }

    Most of these regions will be discussed later, based on the components that use them.

    @subsection (label=subsec:choices) Choices for this project\

    For simplicity, I decided not to break down all these areas into different regions of memory
    in the emulator, but I opted for an easier solution, which is to create an array of 65'536 bytes,
    since the data bus was 8 bits-long, so every address will have exactly one byte of data.
    \\
    There is a trade-off in choosing this approach tough.
    On one hand, it makes things simpler to manage, we can have all the memory in one place and it really helps when debugging,
    but on the other hand, it is not entirely correct.
    Each region of memory has different restrictions, cartridge memory should be read-only, 
    some areas might not be fully readable and writable sometimes (we will see an example when implementing the PPU).
    \\
    By choosing this option, we are making all the memory readable and writable for everyone, 
    so tecnically, the game could edit its own code (and this actually happened when I was emulating Tetris!).

    @subsection (label=subsec:memory-implementation) Implementation\

    @code (language=C++, label=lst:memory) ./code/memory.code\

    This is the entire memory structure.
    Every component we create will have access to this structure in order to read from and write to memory 
    using the two operator[] functions. I have also added a **dump** function that writes 
    all the bytes to a binary file at the moment the function is called, for easier debugging.
    The **init** function just initializes the array by setting all values to 0.
    This is **not** actually done in a real Game Boy, as the memory tipically contains random values when powered on.
    However, I decided to initialize it with all zeros to make debugging easier by allowing me to see if any memory has changed.

    @newpage\

    @section (label=sec:cpu) CPU\
    The first component we likely want to implement is the Central Processing Unit (CPU).
    This component is the most important in our circuit, and is the one that coordinates the other components, executes the program we give to it etc.
    Thus, the first thing I had to implement were all the instructions that the processor could run.
    
    @subsection (label=subsec:architecture-considerations) Architecture and considerations\

    The Game Boy's CPU is a custom-made by Sharp Corporation (which had a close relationship with Nintendo at that time),
    it is often referred to as **DMG-CPU** or **Sharp SM83** and runs at around 4.19 MHz.
    When making the processor a lot of inspiration was taken from the Zilog 80 and the Intel 8080.
    Personally, I recently had the possibility to work with a real Z80, and over the past few months, 
    I have gained hands-on experience with its architecture.
    Specifically, when studying the Zilog, I noticed some differences and similarities with the Game Boy's processor.
    \\
    For example, the Nintendo processor lacks the IX and IY registers, which in the Zilog were used to set a base address that could be offset with the 
    $LD (IX + d), r$ and $LD (IY + d), r$ to save instruction bytes.
    Instead, the DMG-CPU introduced a brand new load instruction, LDH (load from high memory), 
    which always offsets from address **FF00**, 
    pointing to **High-RAM** and the **I/O registers**.
    \\
    I think custom-making their own CPU was the perfect choice for Nintendo, as it allowed them to implement changes like these to better suit their needs, save instruction bytes, and increase performace.
    \\
    CPUs are the main core of every computer and what they do most of the time is execute instructions defined in some memory.
    In the next section, we will give a brief summary of the different types of instructions.
    But what is most important for now is to understand that the majority of these operate on internal registers and external memory.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | >{\centering}p{11mm} | >{\centering}p{11mm} | c | }
            \toprule
            \multicolumn{2}{|c|}{8-bit registers} & 16-bit pairs \\
            \midrule
            A\textsuperscript{*} & F\textsuperscript{**} & AF \\
            B & C & BC \\
            D & E & DE \\
            H & L & HL \\
            \midrule

            \addlinespace[1ex]
            \multicolumn{3}{l}{\textsuperscript{*}Accumulator}
            \multicolumn{3}{l}{\textsuperscript{**}Flags}
        \end{tabular}

        \begin{tabular}{ | c | c | }
            \toprule
            16-bit register & Description \\
            \midrule
            SP & Stack Pointer \\
            PC & Program Counter \\
             & \\
             & \\
            \midrule

            \addlinespace[1ex]
            \multicolumn{3}{l}{}
            \multicolumn{3}{l}{}
        \end{tabular}

        \caption{Game Boy's registers}
        \end{table}
    }

    Registers are the fastest memory to access because it is already inside the processor.
    However their size is very limited, so we cannot have everything in them.
    That is why the CPU has a set of instructions for loading data to and from larger memory.

    @subsection (label=subsec:op-tables) The op-tables\
    We can arrange all the instructions in tables, called opcode-tables, 
    based on their identifier byte.
    \\
    The Game Boy has 2 op-tables which are shown in Figure @ref fig:opcode-tables\. 
    Instructions with similar behaviors have been marked with the same color.
    Since a single byte (one op-table) was insufficient to cover all instructions,
    an additional table was made, which however uses 2-byte instructions, with the first one always being *0xCB* in hexadecimal (acting as a prefix), covering all bit operations.
    \\
    By briefly examining the different instructions, you can see that most of them perform the following operations:
    @list {
        @item {
            Loading values into registers
        }
        @item {
            Adding and subtracting values between registers
        }
        @item {
            Reading from and writing to memory
        }
        @item {
            Comparing values and manipulating individual bits in registers
        }
    }

    Obviously other instructions also do other kinds of operations but, as I have said above, most of them operate on the CPU's registers.

    @figure (H) {
        @subfigure (width=1$$textwidth$$, H) {
            @graphic (scale=1.35, center) ./images/optable1.png\
        }
        @latex {
            \par\bigskip
        }
        @subfigure (width=1$$textwidth$$, H) {
            @graphic (scale=1.35, center) ./images/optable2.png\
        }
        @caption Game Boy's opcode-tables\
        @label fig:opcode-tables\
    }

    @newpage\

    It is important to say that some operations depend of results coming from previous instructions.
    These results are saved in the so called *flags*.
    Each flag would be represented by a single bit, which is set to 1 when active, and all the flags are stored together inside the *F* register.
    Later, we will see that for simplicity I chose to use a separate variable for each flag, instead of using a single *F* variable.
    \\
    These flags are:
    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | }
            \toprule
            Bit* & Name & Description \\
            \midrule
            7 & zf & Zero flag \\
            6 & n & Add/sub flag \\
            5 & h & Half carry flag \\
            4 & cy & Carry flag \\
            3-0 & - & Not used \\
            \midrule

            \addlinespace[1ex]
            \multicolumn{3}{l}{\textsuperscript{*}bit position inside the \textit{F} register}
        \end{tabular}

        \caption{DMG-CPU's flags}
        \end{table}
    }

    @list {
        @item {
            **Zero flag**
            \\
            Set if the result of an operation is 0 \\
            Used for conditional jumps
        }
        @item {
            **Add/sub flag**
            \\
            1 if the previous operation was an addition, 0 if it was a subtraction \\
            Used for DAA instructions only
        }
        @item {
            **Half carry flag**
            \\
            Set when there is a carry between the lower 4 bits of the operands during an arithmetic operation. It indicates that the lower nibble (4 bits) has overflowed.
        }
        @item {
            **Carry flag**
            \\
            Set when an arithmetic operation causes a carry beyond the most significant bit of a byte (either the first or the second one in 16-bit operations) in addition, or a borrow when subtracting.
            Also set when a rotate/shift operation has shifted out a 1.
        }
    }

    Instructions also can take different amount of clock cycles to execute.
    (TODO)

    @newpage\

    @subsection (label=subsec:cpu-implementation) Implementation\
    Thus, the first task I had to do was to implement every single instruction shown above, 
    so that my virtual CPU would imitate the original Game Boy's processor behavior.
    
    @code (language=C++, label=lst:cpu-struct) ./code/cpu.code\

    This is the CPU structure, as you can see I defined all the registers and flags and I also implemented some utility functions.
    \\
    The two functions we need to focus on now are the **execute** and the @latex { \textbf{exec\_op} } function.
    
    @newpage\

    The **execute** function is called by the main loop and, besides executing an instruction, it also handles interrupts.

    @code (language=C++, label=lst:cpu-execute) ./code/execute.code\

    While the @latex { \textbf{exec\_op} } is responsible for handling the operations.

    @code (language=C++, label=lst:cpu-ops) ./code/cpu-ops.code\

    @newpage\

    @section (label=sec:debugging) Debugging the CPU\
    It was now time to test if my CPU worked, I decided to do so by giving the Game Boy boot program to my emulator and see how it would behave.

    @subsection (label=subsec:boot) The boot ROM\

    The Game Boy has a little program burned inside the CPU that gets executed when the console is powered on and, among other things, shows the  @latex {Nintendo\textregistered\xspace} logo.
    This code is exactly **256 bytes** and is stored in the first 256 addresses 
    (from 0000-00FF in hexadecimal).
    \\
    I decided to download the binary file and start disassemblying by myself and studying from scratch.
    \\
    (DISASSEMBLY MAYBE)
    \\

    @subsection (label=subsec:boot-analysis) Boot code analysis\

    For anyone interested, I will attach my disassembly along with some comments and thoughts I jotted down while studying it.
    \\
    Anyways, here is what the code does:
    @list {
        @item {
            Resets VRAM
        }
        @item {
            Sets the audio to play the famous "ba-ding!" sound
        }
        @item {
            Loads the Nintendo logo from the game cartridge into VRAM to display it on screen
        }
        @item {
            Scrolls the logo
        }
        @item {
            Checks if the Nintendo logo is correct by comparing it with its own version; if not, the Game Boys stops executing.
        }
    }

    Some peculiar things are happening in this code that I have not been able to explain.
    The Game Boys contains the entire Nintendo logo (including the registered trademark), but it only displays the R symbol on screen, while the "Nintendo" text is loaded from the game cartridge. Additionally, the logo is displayed on screen **before** it is checked for correctness.

    @newpage\

    @subsection (label=subsec:execution-so-far) The execution so far\

    With this being said, I finally loaded the boot ROM into memory and started executing.

    @code (language=C++, label=lst:rom-load) ./code/rom-load.code\

    I checked whether the registers that were supposed to be modified had the correct values to verify if my CPU implementation was accurate--and it was!
    \\
    The only issue now is that execution stops between addresses **0x64** and **0x68**. Looking at my disassembly, I noticed that the code was looping until register **FF44** reached **0x90**. However, after examining the rest of the code, I saw that this register was never modified, meaning it must be  a read-only register managed by another component.
    This component is the PPU (Pixel Processing Unit) which handles rendering on the display. Since the PPU is rather complex and long to implement, I decided to break it down into sections and follow the order in which I implemented it.
    \\
    Before working on the PPU, though, I first implemented two simpler components.

    @newpage\

    @section (label=sec:timers) Timers\

    As the name suggests, timers are in charge of measuring time and execute some code every certain time.
    One classic application that uses timers is a game where (pseudo) randomness is involved.
    We can get a random value every time we try to read the DIV register (the core counter) for example, because games execution follows an unpredictable order and because instructions take different amount of clock cycles to complete, the value in the DIV register will likely be at a different value each time.

    @subsection (label=subsec:structure) Structure\

    The timer has **four** mapped registers, two of them are for counting, while the other two are for configuring them.

    @subsubsection (label=subsubsec:div) DIV\

    The DIV register is mapped to address **0xFF04** and is the core of the whole system.
    Internally, it is a 16-bit counter which is incremented every single clock cycle, although only the upper 8 bits are mapped to memory.
    The DIV register can be read from at anytime, writing to it will reset the whole 16-bit register to 0.

    @subsubsection (label=subsubsec:tima) TIMA\

    TIMA is a little more complex and gives us the possibility to count at different rates.
    It is mapped to address **0xFF05** and can be configured using the two registers TMA and TAC.

    @subsubsection (label=subsubsec:tac) TAC\

    This register controls the behavior of TIMA and is mapped to address **0xFF07**.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | c | }
            \toprule
            & 7 6 5 4 3 & 2 & 1 0 \\
            \midrule
            TAC & & Enable & Clock select \\
            \midrule
        \end{tabular}

        \caption{TAC flags}
        \end{table}
    }

    Bit 2 just enables or disables TIMA's counting, while bits 1 and 0 set TIMA's incrementing frequency.
    Notice that 1 M-Cycle is equal to 4 clock cycles.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | }
            \toprule
            Clock select & Frequency \\
            \midrule
            00 & 256 M-Cycles \\
            01 & 4 M-Cycles \\
            10 & 16 M-Cycles \\
            11 & 64 M-Cycles \\
            \midrule
        \end{tabular}

        \caption{TAC flags}
        \end{table}
    }

    @subsubsection (label=subsubsec:tma) TMA\

    TMA is mapped to register **0xFF06**
    When TIMA overflows, it is reset to the value stored in the TMA register and an interrupt is requested (we will them see later).
    An example of use can be the following: if TMA is set to 0xFF and the frequency set in TAC is 256 M-Cycles, some piece of code gets executed every 256 M-Cycles.

    @subsubsection (label=subsubsec:timing-oddities) Timing behaviors\

    When TIMA overflows, it does not get reset instantly. Instead, it contains a value of zero and waits for a duration of four clock cycles before it is updated.
    This update can be **aborted** by writing **any** value to TIMA during these four clock cycles. In this case, TIMA keeps the value that was written and an interrupt does **not** get requested.
    However, if TIMA is written on the **same** clock cycle on which the reload occurs, the write is ignored. While if TMA is written on the same clock cycle on which the reload occurs, TMA is updated **before** its value is loaded into TIMA.

    @subsection (label=subsec:implementation) Implementation\

    I decided not to implement these oddities, although I **did** implement the TIMA overflow abort.
    \\
    The **update** function structure is the following.

    @newpage\

    @code (language=C++, label=lst:timers) ./code/timers.code\

    @newpage\

    @section (label=sec:interrupts) Interrupts\

    An Interrupt is a signal sent to the CPU by other components, temporarily pausing the CPU's current execution to handle an urgent task. Once the task is completed, the CPU resumes what it was doing.
    Interrupts are still present in modern processors and are used to notify the Operating System when an event occurrs. They can also be triggered by a subprogram to request OS services. For those familiar with assembly, calling an interrupt is equivalent to making a **syscall**, such as writing output to the terminal.

    @subsection (label=subsec:how-they-work) How they work\

    When a component wants to trigger an interrupt, it sets the CPU's interrupt pin to HIGH.
    If the CPU acknowledges the request, the component is then allowed to place an 8-bit vector on the data bus, specifying the type of interrupt that occurred.
    \\
    It is important to specify that an interrupt is acknowledged **only** if the IME flag is set.
    IME (Interrupt Master Enable) is a flag internal to the CPU, it cannot be read in any way and can only be modified by some instructions or events.
    For example, IME is set to 0 (interrupts are disabled) while an interrupt routine is being executed, preventing new interrupts from being triggered until that routine finishes.
    A component requests an interrupt by writing to the **IF** (Interrupt Flag) register, where each bit represents a different type of interrupt.
    Additionally, the **IE** (Interrupt Enable) register, which is configurable by the programmer, specifies which interrupt the CPU should handle.
    \\
    The CPU executes the interrupt handler **only** if:
    @list {
        @item {
            The corresponding bit is set in both **IF** and **IE** registers.
        }
        @item {
            **IME** is set to 1 (interrupts are enabled).
        }
    }

    @subsection (label=subsec:types-interrupts) Types of interrupts\

    These are the different types of interrupts, each with a specific address where the handler execution code begins.

    @subsubsection (label=subsubsec:vblank) VBlank\

    This interrupt is requested every time the Game Boy enters the VBlank mode, we will see it when we will talk about the PPU.
    It occurs around 59.7 times per second and starts at address **0x0040**.

    @subsubsection (label=subsubsec:lcd) LCD STAT\

    This interrupt can be configured using register **0xFF41** to choose when it should be triggered (again, we will talk about it with the PPU).
    A STAT interrupt will be triggered only if there is a transition from LOW to HIGH on the STAT interrupt line.
    Its handler address is **0x0048**.

    @subsubsection (label=subsubsec:timer) Timer\

    As described in the Timers section, this interrupt occurs every time TIMA overflows. Its handler address is **0x0050**.

    @subsubsection (label=subsubsec:serial) Serial\

    The serial interrupt is requested when a serial data transfer is completed.
    Two Game Boy systems could communicate using a link cable, this thing is not implemented in the emulator, thus the interrupt is never requested.
    Its handler address is **0x0058**.

    @subsubsection (label=subsubsec:joypad) Joypad\

    The Joypad interrupt is requested when any of the bits in the Joypad register changes from HIGH to LOW. As we will see later when we will talk about Joypad emulation, this happens when a button is pressed. Its handler address is **0x0060**.

    @subsection (label=subsec:if-ie-regs) IF and IE registers\

    The IE register is located at **0xFFFF** and controls whether an interrupt handler may be called.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | c | c | c | c | }
            \toprule
            & 7 6 5 & 4 & 3 & 2 & 1 & 0 \\
            \midrule
            IE & & Joypad & Serial & Timer & LCD STAT & VBlank \\
            \midrule
        \end{tabular}

        \caption{IE flags}
        \end{table}
    }

    While the IF register is located at **0xFF0F** and controls whether an interrupt handle is being requested.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | c | c | c | c | }
            \toprule
            & 7 6 5 & 4 & 3 & 2 & 1 & 0 \\
            \midrule
            IF & & Joypad & Serial & Timer & LCD STAT & VBlank \\
            \midrule
        \end{tabular}

        \caption{IF flags}
        \end{table}
    }

    In case more than one interrupt is requested at the same time, the one with the highest priority is serviced first. The priorities follow the order of the bits in the IE and IF registers, with bit 0 (VBlank) having the highest priority and bit 4 having the lowest one.

    @subsection (label=subsec:interrupts-implementation) Implementation\

    This is the @latex { \textbf{handle\_interrupts} } function that, as we saw before, is called by the CPU **update** function.

    @code (language=C++, label=lst:interrupts) ./code/interrupts.code\

    @newpage\

    @section (label=sec:ppu-first) PPU - Very basic start\

    It was finally time to work on the PPU and ensure the boot ROM could continue executing properly.
    
    @subsection (label=subsec:ppu-general-introduction) General introduction\

    The PPU has been mentioned many times so far because it is the second most important component inside the Game Boy--and also the most complex, even more so than the CPU.
    \\
    When I first began working on this component I did not aim to render anything on the screen immediately. My initial goal was merely to bypass the code segment that was blocking the boot execution, which involved a specific register.
    However, we first need some theory and some basic knowledge to understand how the PPU works.

    @subsubsection (label=subsubsec:the-screen) The screen\

    The original Game Boy display was a 160x144 pixel LCD (Liquid Crystal Display), which could display up to 4 different shades of gray.

    @subsubsection (label=subsubsec:tiles) Tiles\

    However, pixels could not be manipulated individually. Instead, they were grouped into **tiles**--fixed **8x8 pixel textures** that could be placed on the screen within a predefined grid. This resulted in a screen that was 20x18 tiles in size.
    \\
    Since there were only 4 shades of gray, only 2 bits per pixel were required, making each tile **16 bytes** (2 bytes per row).
    These tiles were stored in VRAM from address **0x8000** to **0x97FF**

    @figure (H) {
        @graphic (width=1$$textwidth$$) images/tile-explanation\
        @centering\
        @caption Tile explanation\
        @label fig:tile-explanation\
    }

    @subsubsection (label=subsubsec:display-layers) Display layers\

    But how do we use these tiles?
    The Game Boy organizes its display into three separate layers: the **Background**, the **Window** and the **Sprites**.

    @paragraph The Background\

    is a 32x32 tile grid. Since the Game Boy can only display a 20x18 tile section, it can be scrolled using **SCX** and **SCY** registers, respectively Scroll X and Scroll Y registers.

    @paragraph The Window\

    is another 32x32 tile grid that acts as an overlay over the Background. the position of this Window is determined using the **WX** and **WY** registers, Window X and Window Y respectively.

    @paragraph Sprites\
    are the objects that move inside the screen, like the player character in a game. It can be either 1 tile or 2 tiles (8x16 pixels) and they are not limited by the Background or the Window grid.
    Due to memory size, there can be up to 40 sprites and up to 10 sprites per row.

    @subsubsection (label=subsubsec:tile-data) Layers in memory\

    But where are all of these layers stored? \\
    The Background and Window are stored in two **Background Maps**, located at memory ranges **0x9800-0x9BFF** and **0x9C00-0x9FFF**. Which map represents the Window and which one the Background is configured using the **LCDC register**.
    Bytes in these maps are organized row by row, with each byte representing a tile via a **tile number**. The first byte corresponds to the top-left tile, the next one to the tile to its right, and so on.
    \\
    A **tile number** is merely an index pointing to a tile in the tile data region. There are **two methods** the Game Boy uses to interpret these tile numbers.
    @list {
        @item {
            The **8000 method** treats the tile number as an **unsigned 8-bit integer** and uses it as an offset from the base address **0x8000**. For example, a tile number of 0 would point to the tile that starts at **0x8000**, a tile number of 1 would point to **0x8010** etc.
        }
        @item {
            The **8800 method** instead treats the tile number as a **signed 8-bit integer** and offsets it from the base address **0x9000**. Hence, a tile number of 0 would point to **0x9000** while a tile number of 0xFF (-1) would point to **0x8FF0** etc.
        }
    }
    The Background and the Window can be configured to use either the 8000 or 8800 method using the **LCDC register**, while the Sprites always use the 8000 one.
    \\
    Sprites are stored in the region usually called OAM (Object Attribute Memory). This is because each sprite does not just have to include a tile number but it also needs to supply other information.
    This OAM section ranges from **0xFE00** to **0xFE9F**, each sprite entry is structured as follows:
    \\
    TODO: maybe add more details about this
    @list {
        @item {
            **Byte 0 - Y-Position**
        }
        @item {
            **Byte 1 - X-Position**
        }
        @item {
            **Byte 2 - Tile number**
        }
        @item {
            **Byte 3 - Sprite flags**
        }
    }

    @subsection (label=subsec:the-rendering-process) The rendering process\

    Now that we have a general understanding of how memory is managed by the PPU, we can start discussing the **rendering process**.
    Keep in mind that for this initial implementation, I did not aim to **actually** create a window and render tiles.
    Instead, I wanted to **simulate** rendering by updating the registers correctly.
    The goal was to just **"pretend"** rendering was happening in order to bypass the infinite loop we were stuck in.

    @subsubsection (label=subsubsec:how-tiles-are-rendered) How tiles are rendered\

    Although the games organize graphics into tiles, the PPU does not actually set the pixels on a tile-by-tile basis. Instead, frames are rendered row by rowâ€”these rows are commonly referred to as **scanlines**.
    The number of the scanline the PPU is currently working on is stored in the **LY register**, mapped to address **0xFF44**--exacly the register that was being checked in our infinite loop! The boot program was waiting for the PPU to process the 90th row.
    \\
    Every time a scanline is processed, the PPU cycles throught different **modes**.
    I have decided to explain them in the order they are executed during rendering, rather than by their mode identifier.

    @paragraph OAM scan\
    is entered at the beginning of every scanline (except for V-Blank), the PPU looks for sprites that are on the **current scanline** and stores them in a local buffer which can contain up to 10 sprites (this is why only 10 sprites per row are allowed). A sprite check happens every 2 clock cycles for a total amount of 80 clock cycles, since there can be up to 40 sprites.

    @paragraph Drawing\
    is the mode in which the PPU actually transfers pixels to the LCD. Due to various factors, the duration of this mode is not fixed--it can take as little as 172 clock cycles, in the best case and up to 289 in the worst case.

    @paragraph H-Blank\
    acts as a kind of padding to ensure each scanline takes exactly 456 clock cycles. Nothing significant happens here as the PPU just pauses.

    @paragraph V-Blank\
    is a more interesting mode instead.
    As mentioned earlier, the Game Boy display has 144 visible pixel rows. However, the PPU processes a total of 154 scanlines.
    The remaining 10 scanlines are part of the V-Blank period. Each of these takes 456 clock cycles--just like a regular scanline--and, similar to H-Blank, nothing really happens.
    Notice that V-Blank is the only time when the CPU **can safely access VRAM** (although tecnically it can also be accessed during OAM scan and H-Blank). In later implementations we will see how games use this V-Blank period for **DMA transfers** and much more.

    @newpage\

    To make everything even clearer, I will include a diagram from the Game Boy Pandocs that visually illustrates the concepts explained above.

    @figure (H) {
        @graphic images/ppu-modes.png\
        @centering\
        @caption PPU modes timing diagram\
        @label fig:ppu-modes\
    }

    @newpage\

    @subsubsection (label=subsubsec:ppu-registers) PPU registers\

    Now let's take a look at the registers that allow the processor to control the PPU.

    @paragraph LCD Control (LCDC)\
    is mapped to address **0xFF40** and contains multiple flags that determine what is displayed and how everything is configured.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | p{1cm} | p{4cm} | p{6cm} | }
            \toprule
            Bit* & Name & Description \\
            \midrule

            7 & LCD Display enable & Setting this bit to 0 \textbf{disables} the PPU and the screen entirely
            \\[25pt]

            6 & Window Tile Map Select &
            If set to 1, the Window will use the background map located at \textbf{0x9C00-0x9FFF}; otherwise, it will use \textbf{0x9800-0x9BFF}.
            \\[50pt]

            5 & Window Display Enable & Setting this bit to 0 completely hides the Window layer
            \\[25pt]

            4 & Tile Data Select & Setting this bit to 1 will use the \textbf{8000 method}; otherwise, it will use the \textbf{8800 method}
            \\[35pt]

            3 & Background Tile Map Select & Setting this bit to 1 will use the background map located at \textbf{0x9C00-0x9FFF}; otherwise, it will use \textbf{0x9800-0x9BFF}
            \\[45pt]

            2 & Sprite Size & By setting this bit to 1, sprites will have a size of 1x2 tiles; otherwise, they will be 1x1 tiles
            \\[35pt]

            1 & Sprite Enable & Setting this bit to 0 will completely disable sprites
            \\[25pt]

            0 & Background/Window Enable & Setting this bit to 0 will completely disable the Background \textbf{and} the Window \\
            \midrule

            \addlinespace[1ex]
            \multicolumn{3}{l}{\textsuperscript{*}bit position inside the \textit{LCDC} register}
        \end{tabular}

        \caption{LCD Control register flags}
        \end{table}
    }

    @newpage\

    @paragraph LCD Status\
    is mapped to address **0xFF41** and provides both configuration options for the STAT interrupt (previously explained) and information about the current status of the PPU.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | p{1cm} | p{4cm} | p{6cm} | }
            \toprule
            Bit* & Name & Description \\
            \midrule

            7 & Unused & Always 1
            \\[15pt]

            6 & LYC=LY Condition & Fires a STAT interrupt whenever LY register value is equal to LYC register value
            \\[35pt]

            5 & Mode 2 Condition & Fires a STAT interrupt whenever the PPU enters mode 0 (OAM scan)
            \\[25pt]

            4 & Mode 1 Condition & Fires a STAT interrupt whenever the PPU enters mode 1 (V-Blank)
            \\[25pt]

            3 & Mode 0 Condition & Fires a STAT interrupt whenever the PPU enters mode 0 (H-Blank)
            \\[25pt]

            2 & Coincidence Flag & This bit is set 1 if the value in LY register is equal to the value in LYC register
            \\[25pt]

            1-0 & PPU mode & indicates (in binary) which mode the PPU is currently working on \\
            \midrule
        \end{tabular}

        \caption{LCD Status register flags}
        \end{table}
    }

    Bits 6-3 are used to enable specific conditions under which a STAT interrupt can be requested, while bits 2-0 reflect the current status of the PPU, allowing the CPU to know what the PPU is doing.

    @paragraph SCY, SCX\
    are located at memory addresses **0xFF42** and **0xFF43**, respectively, and specify the top-left coordinates of the visible area within the Background map.

    @paragraph WY, WX\
    are located at memory addresses **0xFF4A** and **0xFF4B**, respectively, and specify the top-left coordinates of the Window map.

    @newpage\
    @paragraph BGP\
    is mapped to address **0xFF47** and assigns gray shades to the color indices of the Background and Window tiles.
    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | c | c | }
        \toprule
        & 7-6 & 5-4 & 3-2 & 1-0 \\
        \midrule
        Colors & \textbf{ID 3} & \textbf{ID 2} & \textbf{ID 1} & \textbf{ID 0} \\
        \midrule
        \end{tabular}
        \end{table}
    }
    Each of the two-bit identifiers map to a color, with 0 being completely white and 3 being completely black.

    @paragraph OBP0, OBP1\
    are located at memory addresses **0xFF48** and **0xFF49**, respectively, and contains the two palette data for sprites. These registers work exactly like BGP, except for the lower two bits, which are ignored since color index 0 is always transparent for sprites.

    @paragraph LY\
    as we said earlier is the register that specifies which scanline the PPU is currently working on and is mapped to address **0xFF44**

    @paragraph LYC\
    (LY Compare), as we saw earlier, is the register used to set the \textbf{Coincidence flag} inside LCDS register and is mapped to **0xFF45**.

    @subsection (label=subsec:first-ppu-implementation) First implementation\
}
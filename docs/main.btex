@class article\

@latex {
    \usepackage{makecell}
    \usepackage{multirow}
    \usepackage{xspace}
    \usepackage{textcomp}
    \usepackage{array}
    \usepackage{booktabs}
    \usepackage[export]{adjustbox}[2011/08/13]
}

@title Emulation\
@date\
@author Takanen Edoardo\

@document {
    @maketitle\

    @center {
        @LARGE\ Abstract
    }

    (still to be placed)
    \\
    images from:
    @list {
        @item {
            https://www.pastraiser.com/cpu/gameboy/gameboy_opcodes.html
        }
    }
    
    @newpage\

    @tableofcontents\
    @newpage\

    @section (label=sec:introduction) Introduction\
    As a kid, I used to play with some @latex { Nintendo\textsuperscript{\textcopyright} } consoles like the Wii or the DS and I have always been keen about the games they make.
    This passion for videogames grew on me so that I got interested in the making process of them, leading to game development.
    I never asked myself one question, though, until this year, which is how are these games able to run onto this consoles? and how can people
    make emulators so that I could play on my personal computer?
    Thus, I decided to embrace the unknown world of emulation, because I have always been fascinated by it but always took it for granted.
    \\
    Emulation is not well explained on the Internet.
    Mainly, the results you will find if you search for it are "the program pretends to be the console" or "you will be able to play old titles".
    Unfortunately I was not satisfied with these responses and I wanted to know more. Thus, my emulation journey started with looking for a full definition of this process.
    \\
    I will try to give my own definition of emulation, so that I can lay a starting point to a general knowledge that will be then deepened during the paper.
    With this being said, to "make an emulator" means to develop the software that will do exactly what the hardware of the console does, so that when plugging the game data,
    the program will know how to read and handle it. \\
    Emulation can only happen when the machine in which we run the software is more powerful than the hardware we want to emulate.
    For example, if our console has 2Kb of memory, for sure we are not able to emulate it on a computer that has 2Kb or less, since we also have to consider that
    the host computer will have an operating system running (which uses some of the RAM).
    I chose to make a Game Boy emulator, because while looking for the retro consoles, it seemed the least difficult when talking about the hardware structure complexity,
    meaning a good way to start tackling this topic.
    @newpage\

    @section (label=sec:premises) Premises\
    This emulator project is purely for understanding the concepts and the theory about how a machine like a console (or similarly a computer) is made (and also for fun).
    There are many better-developed Game Boy emulators online, and making one that could compete with the other popular ones is nowhere near my goals.
    In addition, I could not achieve the level of knowledge I want to reach if I just looked at other people's codes, I wanted to **fully** understand the subject.
    Obviously though I have to start somewhere, I do not have the skills to reverse-engineer a real Game Boy (although it would be an extremely interesting challenge),
    for this reason I will only consult theory guides made by many passionate developers and hackers that already did the work of studying the Game Boy from scratch for us.
    For a better understanding, I used **two** sources for this project, in order to have a dual perspective on the study.\\
    For anyone who would like to dig into this challenge too, the guides are @href https://gbdev.io/ GBDev\$$fs$$ and @href https://hacktix.github.io/GBEDG/ GBEDG\.
    \\
    **What this paper is not?** \\
    This paper is not and was not intended as a guide, I previously attached some real references.
    This document is a report of my journey throughtout the development of the emulator, made to understand the fundamentals of what is around us, from personal computers 
    to smartphones. It could also be a way for readers to get passionate about this topic and an inspiration for them to make their own emulators 
    (or even better, their own consoles!).
    @newpage\
    
    @section (label=sec:general-structure) General Structure\
    The first thing I want to cover is in what way we want to structure our emulator.

    @code (language=C++, label=lst:general-structure) ./code/general-structure.code\

    Actually, when we look at the circuit inside the Game Boy, all the components are, on one side, all on their own, they all execute at the same time.
    The CPU could be executing a simple addition, while the PPU could be rendering graphics onto the screen, all of these things happen simultaneously.
    This **can** be done with software, but would mean more complexity. Hence we will pick a less complicated path, and decide to execute the components one at a time.

    @code (language=C++, label=lst:clocking) ./code/clocking.code\ 

    The real hardware is driven by the clock, while my implementation will be driven by how many clock cycles an instruction took.
    This may cause some bugs and imprecisions in the emulator (and that was my main concern), but in the end it worked just fine.
    @newpage\

    @section (label=sec:memory) Memory\
    Before looking at the main components that shape the Game Boy hardware, I would like to focus on how memory is subdivided inside the console.\\

    @subsection (label=subsec:memory-mapping) Memory Mapping\
    The address bus had 16 bits, meaning there could be 65'536 unique addresses (64Kb). \\
    Since the Game Boy did not have a flash memory, those 64Kb were all the console could access 
    (this includes all the different RAMs, the cartridge data, and the registers made to control various components).
    Internally inside the Game Boy, there is some logic that specifies what component will be activated 
    based on the requesting address, but we do not have to worry about it since we are not dealing with actual hardware this time.
    \\
    These are the regions into which the memory is split, along with a brief description of their use.
    Notice that some areas are marked as "Prohibited", though Nintendo has not provided an explanation for this.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ ||c | c | c|| }
            \toprule
            Start & End & Description \\
            \midrule
            0000 & 3FFF & 16Kb cartridge ROM \\
            4000 & 7FFF & 16Kb cartridge ROM\textsuperscript{*} \\
            8000 & 9FFF & 8Kb VRAM \\
            A000 & BFFF & 8Kb External RAM \\
            C000 & CFFF & 4Kb Work RAM \\
            D000 & DFFF & 4Kb Work RAM \\
            E000 & FDFF & Prohibited area \\
            FE00 & FE9F & OAM \\
            FEA0 & FEFF & Prohibited area \\
            FF00 & FF7F & I/O Registers \\
            FF80 & FFFE & High RAM \\
            FFFF & FFFF & IE register \\
            \midrule

            \addlinespace[1ex]
            \multicolumn{3}{l}{\textsuperscript{*}switchable}
        \end{tabular}
        \caption{Game Boy memory mapping}
        \end{table}
    }

    Most of these regions will be discussed later, based on the components that use them.

    @subsection (label=subsec:choices) Choices for This Project\

    For simplicity, I decided not to break down all these areas into different regions of memory
    in the emulator, but I opted for an easier solution, which is to create an array of 65'536 bytes,
    since the data bus was 8 bits-long, so every address will have exactly one byte of data.
    \\
    There is a trade-off in choosing this approach tough.
    On one hand, it makes things simpler to manage, we can have all the memory in one place and it really helps when debugging,
    but on the other hand, it is not entirely correct.
    Each region of memory has different restrictions, cartridge memory should be read-only, 
    some areas might not be fully readable and writable sometimes (we will see an example when implementing the PPU).
    \\
    By choosing this option, we are making all the memory readable and writable for everyone, 
    so tecnically, the game could edit its own code (and this actually happened when I was emulating Tetris!).

    @subsection (label=subsec:memory-implementation) Implementation\

    @code (language=C++, label=lst:memory) ./code/memory.code\

    This is the entire memory structure.
    Every component we create will have access to this structure in order to read from and write to memory 
    using the two operator[] functions. I have also added a **dump** function that writes 
    all the bytes to a binary file at the moment the function is called, for easier debugging.
    The **init** function just initializes the array by setting all values to 0.
    This is **not** actually done in a real Game Boy, as the memory tipically contains random values when powered on.
    However, I decided to initialize it with all zeros to make debugging easier by allowing me to see if any memory has changed.

    @newpage\

    @section (label=sec:cpu) CPU\
    The first component we likely want to implement is the Central Processing Unit (CPU).
    This component is the most important in our circuit, and is the one that coordinates the other components, executes the program we give to it etc.
    Thus, the first thing I had to implement were all the instructions that the processor could run.
    
    @subsection (label=subsec:architecture-considerations) Architecture and Considerations\

    The Game Boy CPU is a custom-made by Sharp Corporation (which had a close relationship with Nintendo at that time),
    it is often referred to as **DMG-CPU** or **Sharp SM83** and runs at around 4.19 MHz.
    When making the processor a lot of inspiration was taken from the Zilog 80 and the Intel 8080.
    Personally, I recently had the possibility to work with a real Z80, and over the past few months, 
    I have gained hands-on experience with its architecture.
    Specifically, when studying the Zilog, I noticed some differences and similarities with the Game Boy processor.
    \\
    For example, the Nintendo processor lacks the IX and IY registers, which in the Zilog were used to set a base address that could be offset with the 
    $LD (IX + d), r$ and $LD (IY + d), r$ to save instruction bytes.
    Instead, the DMG-CPU introduced a brand new load instruction, LDH (load from high memory), 
    which always offsets from address **FF00**, 
    pointing to **High-RAM** and the **I/O registers**.
    \\
    I think custom-making their own CPU was the perfect choice for Nintendo, as it allowed them to implement changes like these to better suit their needs, save instruction bytes, and increase performace.
    \\
    CPUs are the main core of every computer and what they do most of the time is execute instructions defined in some memory.
    In the next section, we will give a brief summary of the different types of instructions.
    But what is most important for now is to understand that the majority of these operate on internal registers and external memory.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | >{\centering}p{11mm} | >{\centering}p{11mm} | c | }
            \toprule
            \multicolumn{2}{|c|}{8-bit registers} & 16-bit pairs \\
            \midrule
            A\textsuperscript{*} & F\textsuperscript{**} & AF \\
            B & C & BC \\
            D & E & DE \\
            H & L & HL \\
            \midrule

            \addlinespace[1ex]
            \multicolumn{3}{l}{\textsuperscript{*}Accumulator}
            \multicolumn{3}{l}{\textsuperscript{**}Flags}
        \end{tabular}

        \begin{tabular}{ | c | c | }
            \toprule
            16-bit register & Description \\
            \midrule
            SP & Stack Pointer \\
            PC & Program Counter \\
             & \\
             & \\
            \midrule

            \addlinespace[1ex]
            \multicolumn{3}{l}{}
            \multicolumn{3}{l}{}
        \end{tabular}

        \caption{Game Boy registers}
        \end{table}
    }

    Registers are the fastest memory to access because it is already inside the processor.
    However their size is very limited, so we cannot have everything in them.
    That is why the CPU has a set of instructions for loading data to and from larger memory.

    @subsection (label=subsec:op-tables) The Op-Tables\
    We can arrange all the instructions in tables, called opcode-tables, 
    based on their identifier byte.
    \\
    The Game Boy has 2 op-tables which are shown in Figure @ref fig:opcode-tables\. 
    Instructions with similar behaviors have been marked with the same color.
    Since a single byte (one op-table) was insufficient to cover all instructions,
    an additional table was made, which however uses 2-byte instructions, with the first one always being *0xCB* in hexadecimal (acting as a prefix), covering all bit operations.
    \\
    By briefly examining the different instructions, you can see that most of them perform the following operations:
    @list {
        @item {
            Loading values into registers
        }
        @item {
            Adding and subtracting values between registers
        }
        @item {
            Reading from and writing to memory
        }
        @item {
            Comparing values and manipulating individual bits in registers
        }
    }

    Obviously other instructions also do other kinds of operations but, as I have said above, most of them operate on the CPU registers.

    @figure (H) {
        @subfigure (width=1$$textwidth$$, H) {
            @graphic (scale=1.35, center) ./images/optable1.png\
        }
        @latex {
            \par\bigskip
        }
        @subfigure (width=1$$textwidth$$, H) {
            @graphic (scale=1.35, center) ./images/optable2.png\
        }
        @caption Game Boy opcode-tables\
        @label fig:opcode-tables\
    }

    @newpage\

    It is important to say that some operations depend of results coming from previous instructions.
    These results are saved in the so called *flags*.
    Each flag would be represented by a single bit, which is set to 1 when active, and all the flags are stored together inside the *F* register.
    Later, we will see that for simplicity I chose to use a separate variable for each flag, instead of using a single *F* variable.
    \\
    These flags are:
    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | }
            \toprule
            Bit* & Name & Description \\
            \midrule
            7 & zf & Zero flag \\
            6 & n & Add/sub flag \\
            5 & h & Half carry flag \\
            4 & cy & Carry flag \\
            3-0 & - & Not used \\
            \midrule

            \addlinespace[1ex]
            \multicolumn{3}{l}{\textsuperscript{*}bit position inside the \textit{F} register}
        \end{tabular}

        \caption{DMG-CPU flags}
        \end{table}
    }

    @list {
        @item {
            **Zero flag**
            \\
            Set if the result of an operation is 0 \\
            Used for conditional jumps
        }
        @item {
            **Add/sub flag**
            \\
            1 if the previous operation was an addition, 0 if it was a subtraction \\
            Used for DAA instructions only
        }
        @item {
            **Half carry flag**
            \\
            Set when there is a carry between the lower 4 bits of the operands during an arithmetic operation. It indicates that the lower nibble (4 bits) has overflowed.
        }
        @item {
            **Carry flag**
            \\
            Set when an arithmetic operation causes a carry beyond the most significant bit of a byte (either the first or the second one in 16-bit operations) in addition, or a borrow when subtracting.
            Also set when a rotate/shift operation has shifted out a 1.
        }
    }

    Instructions also can take different amount of clock cycles to execute.
    (TODO)

    @newpage\

    @subsection (label=subsec:cpu-implementation) Implementation\
    Thus, the first task I had to do was to implement every single instruction shown above, 
    so that my virtual CPU would imitate the original Game Boy processor behavior.
    
    @code (language=C++, label=lst:cpu-struct) ./code/cpu.code\

    This is the CPU structure, as you can see I defined all the registers and flags and I also implemented some utility functions.
    \\
    The two functions we need to focus on now are the **execute** and the @latex { \textbf{exec\_op} } function.
    
    @newpage\

    The **execute** function is called by the main loop and, besides executing an instruction, it also handles interrupts.

    @code (language=C++, label=lst:cpu-execute) ./code/execute.code\

    While the @latex { \textbf{exec\_op} } is responsible for handling the operations.

    @code (language=C++, label=lst:cpu-ops) ./code/cpu-ops.code\

    @newpage\

    @section (label=sec:debugging) Debugging the CPU\
    It was now time to test if my CPU worked, I decided to do so by giving the Game Boy boot program to my emulator and see how it would behave.

    @subsection (label=subsec:boot) The Boot ROM\

    The Game Boy has a little program burned inside the CPU that gets executed when the console is powered on and, among other things, shows the  @latex {Nintendo\textregistered\xspace} logo.
    This code is exactly **256 bytes** and is stored in the first 256 addresses 
    (from 0000-00FF in hexadecimal).
    \\
    I decided to download the binary file and start disassemblying by myself and studying from scratch.
    \\
    (DISASSEMBLY MAYBE)
    \\

    @subsection (label=subsec:boot-analysis) Boot Code Analysis\

    For anyone interested, I will attach my disassembly along with some comments and thoughts I jotted down while studying it.
    \\
    Anyways, here is what the code does:
    @list {
        @item {
            Resets VRAM
        }
        @item {
            Sets the audio to play the famous "ba-ding!" sound
        }
        @item {
            Loads the Nintendo logo from the game cartridge into VRAM to display it on screen
        }
        @item {
            Scrolls the logo
        }
        @item {
            Checks if the Nintendo logo is correct by comparing it with its own version; if not, the Game Boys stops executing.
        }
    }

    Note that the Nintendo logo is put in the Background layer--this detail will become clearer once we get to the PPU implementation.
    \\
    For now, anyway, I would like to take a moment to focus on some peculiar things that are happening in this code that I have not been able to explain.
    The Game Boys contains the entire Nintendo logo (including the registered trademark), but it only displays the R symbol on screen, while the "Nintendo" text is loaded from the game cartridge. Additionally, the logo is displayed on screen **before** it is checked for correctness.

    @newpage\

    @subsection (label=subsec:execution-so-far) The Execution So Far\

    With this being said, I finally loaded the boot ROM into memory and started executing.

    @code (language=C++, label=lst:rom-load) ./code/rom-load.code\

    I checked whether the registers that were supposed to be modified had the correct values to verify if my CPU implementation was accurate--and it was!
    \\
    The only issue now is that execution stops between addresses **0x64** and **0x68**. Looking at my disassembly, I noticed that the code was looping until register **FF44** reached **0x90**. However, after examining the rest of the code, I saw that this register was never modified, meaning it must be  a read-only register managed by another component.
    This component is the PPU (Pixel Processing Unit) which handles rendering on the display. Since the PPU is rather complex and long to implement, I decided to break it down into sections and follow the order in which I implemented it.
    \\
    Before working on the PPU, though, I first implemented two simpler components.

    @newpage\

    @section (label=sec:timers) Timers\

    As the name suggests, timers are in charge of measuring time and execute some code every certain time.
    One classic application that uses timers is a game where (pseudo) randomness is involved.
    We can get a random value every time we try to read the DIV register (the core counter) for example, because games execution follows an unpredictable order and because instructions take different amount of clock cycles to complete, the value in the DIV register will likely be at a different value each time.

    @subsection (label=subsec:structure) Structure\

    The timer has **four** mapped registers, two of them are for counting, while the other two are for configuring them.

    @subsubsection (label=subsubsec:div) DIV\

    The DIV register is mapped to address **0xFF04** and is the core of the whole system.
    Internally, it is a 16-bit counter which is incremented every single clock cycle, although only the upper 8 bits are mapped to memory.
    The DIV register can be read from at anytime, writing to it will reset the whole 16-bit register to 0.

    @subsubsection (label=subsubsec:tima) TIMA\

    TIMA is a little more complex and gives us the possibility to count at different rates.
    It is mapped to address **0xFF05** and can be configured using the two registers TMA and TAC.

    @subsubsection (label=subsubsec:tac) TAC\

    This register controls the behavior of TIMA and is mapped to address **0xFF07**.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | c | }
            \toprule
            & 7 6 5 4 3 & 2 & 1 0 \\
            \midrule
            TAC & & Enable & Clock select \\
            \midrule
        \end{tabular}

        \caption{TAC flags}
        \end{table}
    }

    Bit 2 just enables or disables TIMA's counting, while bits 1 and 0 set TIMA's incrementing frequency.
    Notice that 1 M-Cycle is equal to 4 clock cycles.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | }
            \toprule
            Clock select & Frequency \\
            \midrule
            00 & 256 M-Cycles \\
            01 & 4 M-Cycles \\
            10 & 16 M-Cycles \\
            11 & 64 M-Cycles \\
            \midrule
        \end{tabular}

        \caption{TAC flags}
        \end{table}
    }

    @subsubsection (label=subsubsec:tma) TMA\

    TMA is mapped to register **0xFF06**
    When TIMA overflows, it is reset to the value stored in the TMA register and an interrupt is requested (we will them see later).
    An example of use can be the following: if TMA is set to 0xFF and the frequency set in TAC is 256 M-Cycles, some piece of code gets executed every 256 M-Cycles.

    @subsubsection (label=subsubsec:timing-oddities) Timing Behaviors\

    When TIMA overflows, it does not get reset instantly. Instead, it contains a value of zero and waits for a duration of four clock cycles before it is updated.
    This update can be **aborted** by writing **any** value to TIMA during these four clock cycles. In this case, TIMA keeps the value that was written and an interrupt does **not** get requested.
    However, if TIMA is written on the **same** clock cycle on which the reload occurs, the write is ignored. While if TMA is written on the same clock cycle on which the reload occurs, TMA is updated **before** its value is loaded into TIMA.

    @subsection (label=subsec:implementation) Implementation\

    I decided not to implement these oddities, although I **did** implement the TIMA overflow abort.
    \\
    The **update** function structure is the following.

    @newpage\

    @code (language=C++, label=lst:timers) ./code/timers.code\

    @newpage\

    @section (label=sec:interrupts) Interrupts\

    An Interrupt is a signal sent to the CPU by other components, temporarily pausing the CPU current execution to handle an urgent task. Once the task is completed, the CPU resumes what it was doing.
    Interrupts are still present in modern processors and are used to notify the Operating System when an event occurrs. They can also be triggered by a subprogram to request OS services. For those familiar with assembly, calling an interrupt is equivalent to making a **syscall**, such as writing output to the terminal.

    @subsection (label=subsec:how-they-work) How They Work\

    When a component wants to trigger an interrupt, it sets the CPU interrupt pin to HIGH.
    If the CPU acknowledges the request, the component is then allowed to place an 8-bit vector on the data bus, specifying the type of interrupt that occurred.
    \\
    It is important to specify that an interrupt is acknowledged **only** if the IME flag is set.
    IME (Interrupt Master Enable) is a flag internal to the CPU, it cannot be read in any way and can only be modified by some instructions or events.
    For example, IME is set to 0 (interrupts are disabled) while an interrupt routine is being executed, preventing new interrupts from being triggered until that routine finishes.
    A component requests an interrupt by writing to the **IF** (Interrupt Flag) register, where each bit represents a different type of interrupt.
    Additionally, the **IE** (Interrupt Enable) register, which is configurable by the programmer, specifies which interrupt the CPU should handle.
    \\
    The CPU executes the interrupt handler **only** if:
    @list {
        @item {
            The corresponding bit is set in both **IF** and **IE** registers.
        }
        @item {
            **IME** is set to 1 (interrupts are enabled).
        }
    }

    @subsection (label=subsec:types-interrupts) Types of Interrupts\

    These are the different types of interrupts, each with a specific address where the handler execution code begins.

    @subsubsection (label=subsubsec:vblank) VBlank\

    This interrupt is requested every time the Game Boy enters the VBlank mode, we will see it when we will talk about the PPU.
    It occurs around 59.7 times per second and starts at address **0x0040**.

    @subsubsection (label=subsubsec:lcd) LCD STAT\

    This interrupt can be configured using register **0xFF41** to choose when it should be triggered (again, we will talk about it with the PPU).
    A STAT interrupt will be triggered only if there is a transition from LOW to HIGH on the STAT interrupt line.
    Its handler address is **0x0048**.

    @subsubsection (label=subsubsec:timer) Timer\

    As described in the Timers section, this interrupt occurs every time TIMA overflows. Its handler address is **0x0050**.

    @subsubsection (label=subsubsec:serial) Serial\

    The serial interrupt is requested when a serial data transfer is completed.
    Two Game Boy systems could communicate using a link cable, this thing is not implemented in the emulator, thus the interrupt is never requested.
    Its handler address is **0x0058**.

    @subsubsection (label=subsubsec:joypad) Joypad\

    The Joypad interrupt is requested when any of the bits in the Joypad register changes from HIGH to LOW. As we will see later when we will talk about Joypad emulation, this happens when a button is pressed. Its handler address is **0x0060**.

    @subsection (label=subsec:if-ie-regs) IF and IE Registers\

    The IE register is located at **0xFFFF** and controls whether an interrupt handler may be called.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | c | c | c | c | }
            \toprule
            & 7 6 5 & 4 & 3 & 2 & 1 & 0 \\
            \midrule
            IE & & Joypad & Serial & Timer & LCD STAT & VBlank \\
            \midrule
        \end{tabular}

        \caption{IE flags}
        \end{table}
    }

    While the IF register is located at **0xFF0F** and controls whether an interrupt handle is being requested.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | c | c | c | c | }
            \toprule
            & 7 6 5 & 4 & 3 & 2 & 1 & 0 \\
            \midrule
            IF & & Joypad & Serial & Timer & LCD STAT & VBlank \\
            \midrule
        \end{tabular}

        \caption{IF flags}
        \end{table}
    }

    In case more than one interrupt is requested at the same time, the one with the highest priority is serviced first. The priorities follow the order of the bits in the IE and IF registers, with bit 0 (VBlank) having the highest priority and bit 4 having the lowest one.

    @subsection (label=subsec:interrupts-implementation) Implementation\

    This is the @latex { \textbf{handle\_interrupts} } function that, as we saw before, is called by the CPU **update** function.

    @code (language=C++, label=lst:interrupts) ./code/interrupts.code\

    @newpage\

    @section (label=sec:ppu-first) PPU -- Very Basic Start\

    It was finally time to work on the PPU and ensure the boot ROM could continue executing properly.
    
    @subsection (label=subsec:ppu-general-introduction) General Introduction\

    The PPU has been mentioned many times so far because it is the second most important component inside the Game Boy--and also the most complex, even more so than the CPU.
    \\
    When I first began working on this component I did not aim to render anything on the screen immediately. My initial goal was merely to bypass the code segment that was blocking the boot execution, which involved a specific register.
    However, we first need some theory and some basic knowledge to understand how the PPU works.

    @subsubsection (label=subsubsec:the-screen) The Screen\

    The original Game Boy display was a 160x144 pixel LCD (Liquid Crystal Display), which could display up to 4 different shades of gray.

    @subsubsection (label=subsubsec:tiles) Tiles\

    However, pixels could not be manipulated individually. Instead, they were grouped into **tiles**--fixed **8x8 pixel textures** that could be placed on the screen within a predefined grid. This resulted in a screen that was 20x18 tiles in size.
    \\
    Since there were only 4 shades of gray, only 2 bits per pixel were required, making each tile **16 bytes** (2 bytes per row).
    These tiles were stored in VRAM from address **0x8000** to **0x97FF**

    @figure (H) {
        @graphic (width=1$$textwidth$$) images/tile-explanation\
        @centering\
        @caption Tile explanation\
        @label fig:tile-explanation\
    }

    @subsubsection (label=subsubsec:display-layers) Display Layers\

    But how do we use these tiles?
    The Game Boy organizes its display into three separate layers: the **Background**, the **Window** and the **Sprites**.

    @paragraph The Background\

    is a 32x32 tile grid. Since the Game Boy can only display a 20x18 tile section, it can be scrolled using **SCX** and **SCY** registers, respectively Scroll X and Scroll Y registers.

    @paragraph The Window\

    is another 32x32 tile grid that acts as an overlay over the Background. the position of this Window is determined using the **WX** and **WY** registers, Window X and Window Y respectively.

    @paragraph Sprites\
    are the objects that move inside the screen, like the player character in a game. It can be either 1 tile or 2 tiles (8x16 pixels) and they are not limited by the Background or the Window grid.
    Due to memory size, there can be up to 40 sprites and up to 10 sprites per row.

    @subsubsection (label=subsubsec:tile-data) Layers in Memory\

    But where are all of these layers stored? \\
    The Background and Window are stored in two **Background Maps**, located at memory ranges **0x9800-0x9BFF** and **0x9C00-0x9FFF**. Which map represents the Window and which one the Background is configured using the **LCDC register**.
    Bytes in these maps are organized row by row, with each byte representing a tile via a **tile number**. The first byte corresponds to the top-left tile, the next one to the tile to its right, and so on.
    \\
    A **tile number** is merely an index pointing to a tile in the tile data region. There are **two methods** the Game Boy uses to interpret these tile numbers.
    @list {
        @item {
            The **8000 method** treats the tile number as an **unsigned 8-bit integer** and uses it as an offset from the base address **0x8000**. For example, a tile number of 0 would point to the tile that starts at **0x8000**, a tile number of 1 would point to **0x8010** etc.
        }
        @item {
            The **8800 method** instead treats the tile number as a **signed 8-bit integer** and offsets it from the base address **0x9000**. Hence, a tile number of 0 would point to **0x9000** while a tile number of 0xFF (-1) would point to **0x8FF0** etc.
        }
    }
    The Background and the Window can be configured to use either the 8000 or 8800 method using the **LCDC register**, while the Sprites always use the 8000 one.
    \\
    Sprites are stored in the region usually called OAM (Object Attribute Memory). This is because each sprite does not just have to include a tile number but it also needs to supply other information.
    This OAM section ranges from **0xFE00** to **0xFE9F**, each sprite entry is structured as follows:
    \\
    TODO: maybe add more details about this
    @list {
        @item {
            **Byte 0 - Y-Position**
        }
        @item {
            **Byte 1 - X-Position**
        }
        @item {
            **Byte 2 - Tile number**
        }
        @item {
            **Byte 3 - Sprite flags**
        }
    }

    @subsection (label=subsec:the-rendering-process) The Rendering Process\

    Now that we have a general understanding of how memory is managed by the PPU, we can start discussing the **rendering process**.
    Keep in mind that for this initial implementation, I did not aim to **actually** create a window and render tiles.
    Instead, I wanted to **simulate** rendering by updating the registers correctly.
    The goal was to just **"pretend"** rendering was happening in order to bypass the infinite loop we were stuck in. That is why what I am about to explain will not be exhaustive or complete--for now. More detailed explanations will follow later, in the same order I learned them myself.
    By the way, this kind of approach mirros how debugging often works in practice: you implement just enough for things to move forward, then come back to refine later.

    @subsubsection (label=subsubsec:how-tiles-are-rendered) How Tiles Are Rendered\

    Although the games organize graphics into tiles, the PPU does not actually set the pixels on a tile-by-tile basis. Instead, frames are rendered row by rowâ€”these rows are commonly referred to as **scanlines**.
    The number of the scanline the PPU is currently working on is stored in the **LY register**, mapped to address **0xFF44**--exactly the register that was being checked in our infinite loop! The boot program was waiting for the PPU to process the 90th row.
    \\
    Every time a scanline is processed, the PPU cycles through different **modes**.
    I have decided to explain them in the order they are executed during rendering, rather than by their mode identifier.

    @paragraph OAM Scan\
    is entered at the beginning of every scanline (except for V-Blank), the PPU looks for sprites that are on the **current scanline** and stores them in a local buffer which can contain up to 10 sprites (this is why only 10 sprites per row are allowed). A sprite check happens every 2 clock cycles for a total amount of 80 clock cycles, since there can be up to 40 sprites.

    @paragraph Drawing\
    is the mode in which the PPU actually transfers pixels to the LCD. Due to various factors, the duration of this mode is not fixed--it can take as little as 172 clock cycles, in the best case and up to 289 in the worst case.

    @paragraph H-Blank\
    acts as a kind of padding to ensure each scanline takes exactly 456 clock cycles. Nothing significant happens here as the PPU just pauses.

    @paragraph V-Blank\
    is a more interesting mode instead.
    As mentioned earlier, the Game Boy display has 144 visible pixel rows. However, the PPU processes a total of 154 scanlines.
    The remaining 10 scanlines are part of the V-Blank period. Each of these takes 456 clock cycles--just like a regular scanline--and, similar to H-Blank, nothing really happens.
    Notice that V-Blank is the only time when the CPU **can safely access VRAM** (although tecnically it can also be accessed during OAM scan and H-Blank). In later implementations we will see how games use this V-Blank period for **DMA transfers** and much more.

    @newpage\

    To make everything even clearer, I will include a diagram from the Game Boy Pandocs that visually illustrates the concepts explained above.

    @figure (H) {
        @graphic images/ppu-modes.png\
        @centering\
        @caption PPU modes timing diagram\
        @label fig:ppu-modes\
    }

    @newpage\

    @subsubsection (label=subsubsec:ppu-registers) PPU Registers\

    Now let's take a look at the registers that allow the processor to control the PPU.

    @paragraph LCD Control (LCDC)\
    is mapped to address **0xFF40** and contains multiple flags that determine what is displayed and how everything is configured.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | p{1cm} | p{4cm} | p{6cm} | }
            \toprule
            Bit* & Name & Description \\
            \midrule

            7 & LCD Display enable & Setting this bit to 0 \textbf{disables} the PPU and the screen entirely
            \\[25pt]

            6 & Window Tile Map Select &
            If set to 1, the Window will use the background map located at \textbf{0x9C00-0x9FFF}; otherwise, it will use \textbf{0x9800-0x9BFF}.
            \\[50pt]

            5 & Window Display Enable & Setting this bit to 0 completely hides the Window layer
            \\[25pt]

            4 & Tile Data Select & Setting this bit to 1 will use the \textbf{8000 method}; otherwise, it will use the \textbf{8800 method}
            \\[35pt]

            3 & Background Tile Map Select & Setting this bit to 1 will use the background map located at \textbf{0x9C00-0x9FFF}; otherwise, it will use \textbf{0x9800-0x9BFF}
            \\[45pt]

            2 & Sprite Size & By setting this bit to 1, sprites will have a size of 1x2 tiles; otherwise, they will be 1x1 tiles
            \\[35pt]

            1 & Sprite Enable & Setting this bit to 0 will completely disable sprites
            \\[25pt]

            0 & Background/Window Enable & Setting this bit to 0 will completely disable the Background \textbf{and} the Window \\
            \midrule

            \addlinespace[1ex]
            \multicolumn{3}{l}{\textsuperscript{*}bit position inside the \textit{LCDC} register}
        \end{tabular}

        \caption{LCD Control register flags}
        \end{table}
    }

    @newpage\

    @paragraph LCD Status\
    is mapped to address **0xFF41** and provides both configuration options for the STAT interrupt (previously explained) and information about the current status of the PPU.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | p{1cm} | p{4cm} | p{6cm} | }
            \toprule
            Bit* & Name & Description \\
            \midrule

            7 & Unused & Always 1
            \\[15pt]

            6 & LYC=LY Condition & Fires a STAT interrupt whenever LY register value is equal to LYC register value
            \\[35pt]

            5 & Mode 2 Condition & Fires a STAT interrupt whenever the PPU enters mode 0 (OAM scan)
            \\[25pt]

            4 & Mode 1 Condition & Fires a STAT interrupt whenever the PPU enters mode 1 (V-Blank)
            \\[25pt]

            3 & Mode 0 Condition & Fires a STAT interrupt whenever the PPU enters mode 0 (H-Blank)
            \\[25pt]

            2 & Coincidence Flag & This bit is set 1 if the value in LY register is equal to the value in LYC register
            \\[25pt]

            1-0 & PPU mode & indicates (in binary) which mode the PPU is currently working on \\
            \midrule
        \end{tabular}

        \caption{LCD Status register flags}
        \end{table}
    }

    Bits 6-3 are used to enable specific conditions under which a STAT interrupt can be requested, while bits 2-0 reflect the current status of the PPU, allowing the CPU to know what the PPU is doing.

    @paragraph SCY, SCX\
    are located at memory addresses **0xFF42** and **0xFF43**, respectively, and specify the top-left coordinates of the visible area within the Background map.

    @paragraph WY, WX\
    are located at memory addresses **0xFF4A** and **0xFF4B**, respectively, and specify the top-left coordinates of the Window map.

    @newpage\
    @paragraph BGP\
    is mapped to address **0xFF47** and assigns gray shades to the color indices of the Background and Window tiles.
    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | c | c | }
        \toprule
        & 7-6 & 5-4 & 3-2 & 1-0 \\
        \midrule
        Colors & \textbf{ID 3} & \textbf{ID 2} & \textbf{ID 1} & \textbf{ID 0} \\
        \midrule
        \end{tabular}
        \end{table}
    }
    Each of the two-bit identifiers map to a color, with 0 being completely white and 3 being completely black.

    @paragraph OBP0, OBP1\
    are located at memory addresses **0xFF48** and **0xFF49**, respectively, and contains the two palette data for sprites. These registers work exactly like BGP, except for the lower two bits, which are ignored since color index 0 is always transparent for sprites.

    @paragraph LY\
    as we said earlier is the register that specifies which scanline the PPU is currently working on and is mapped to address **0xFF44**

    @paragraph LYC\
    (LY Compare), as we saw earlier, is the register used to set the \textbf{Coincidence flag} inside LCDS register and is mapped to **0xFF45**.

    @subsection (label=subsec:first-ppu-implementation) First Implementation\

    To begin, we will define the structure of our PPU class.

    @code (language=C++, label=lst:ppu) code/ppu.code\

    As the **init** function just initializes some variables, the only important function for now is **update**.

    @newpage\

    @code (language=C++, label=lst:ppu-first-update) code/ppu-update.code\

    As you can see, at lines 28 and 44, we are finally incrementing LY.

    @section (label=sec:execution-so-far-2) The Execution So Far\

    Running the boot program at this stage successfully executes the Nintendo logo scrolling section. However, it gets stuck in another infinite loop--this time during the logo check. Since we have not yet emulated the game cartridge, the comparison cannot succeed. Though, we still managed to make meaningful progress.
    That said, there is no time to celebrate just yet--there is still plenty of work ahead.

    @section (label=sec:ppu-second) PPU -- Further Progress\

    Finally, after putting it off for quite some time, it is finally time to implement the screen and begin rendering at least the Background layer.
    To do so, we first need to understand how the PPU pushes the pixels into the screen.

    @subsection (label=subsec:ppu-fifos) The Pixel FIFO\

    We have already established that the PPU constructs each frame on a scanline basis. The final piece to understand is how these pixels are transferred to the LCD.
    We will see in @ref subsec:fetching-background\ $$fs$$ that during the **drawing phase** tiles are collected singularly, and for each of them the PPU transitions through different phases. At the core of this process, though, are two queues that temporarily store the pixel data before it is sent to the screen.
    I am talking about the **Pixel FIFOs**, FIFO stands for First In First Out, meaning that the first pixel to be pushed into this queue is the first that gets popped out to be rendered.
    We will see that this method of rendering is not ideal, since it implies a lot of timings restrictions that must be followed, slowing down the rendering process. Although the hardware limitations of that time could not offer an alternative solution.
    \\
    There are two pixel FIFOs, one for the Background (or Window) layer, and one for Sprites. Each FIFO can hold up to 16 pixels (2 tile rows) which are only popped out under specific conditions.
    \\
    Each pixel data chunk keeps track of:
    @list {
        @item {
            Color number
        }
        @item {
            Palette (whether OBP0 or OBP1)
        }
        @item {
            Background priority (only relevant for sprites)
        }
    }

    @subsection (label=subsec:fetching-background) Fetching the Background\

    The process of fetching pixels is divided into 4 steps, each one taking 2 clock cycles.

    @list {
        @item {
            During this first step, the **Pixel Fetcher** fetches and stores the tile number of the corresponding tile to be used, following the configurations in the LCDC register.
        }
        @item {
            Using the tile number provided, the first byte of tile data is now fetched and stored internally.
        }
        @item {
            The second byte of tile data is fetched in this third step.
        }
        @item {
            At this stage, the Pixel Fetcher finally attempts to push the decoded pixels into the LCD.
            However, this action is only carried out if the **Background FIFO** is **entirely empty**. If not, the operation is deferred and retried each clock cycle until the FIFO is cleared.
        }
    }

    Here we encounter the first example of those timing restrictions I mentioned earlier. The final step requires the FIFO to be completely empty. If the FIFO happens to be full at this point, it would take **8 clock cycles** (see @ref subsec:pushing-pixels\) to clear it, whereas only 6 clock cycles were needed to reach this stage. Meaning this step must be retried at least twice before it can successfully complete.

    @subsection (label=subsec:pushing-pixels) Pushing Pixels\

    During **each clock cycle**, the PPU attempts to push a pixel to the LCD.
    This can only proceed if **there are elements** present in the **Background FIFO**.
    Merging pixels involves combining one from the Background FIFO with another from the Sprite FIFO--if available. However, for this initial implementation, only pixels from the Background are processed.

    @newpage\

    @subsection (label=subsec:ppu-implementation-2) Second Implementation\

    Let's now take a look at how I chose to implement everything discussed so far.

    @subsubsection (label=subsubsec:ppu-update-2) The Update Method\

    In addition to what was happening before in the **update** method, we are now switching through **real modes** that actually do something.

    @code (language=C++, label=lst:ppu-implementation-2) code/ppu-stages-1.code\

    @subsubsection (label=subsubsec:ppu-draw-method) Draw and Push Methods\

    @code (language=C++, label=lst:ppu-draw) code/ppu-draw.code\

    @newpage\

    @subsubsection (label=subsubsec:ppu-lcd-implementation) The LCD Class\

    I still have not clearified what the **LCD class**--used throughtout these methods--actually does.
    Following the structure of the real Game Boy, I wanted to separate the LCD from the PPU. As a result, the LCD has its own class, although it is quite simple and straightforward.

    @code (language=C++, label=lst:lcd) code/lcd.code\

    As we can see here, we merely keep a **byte array** of pixels, each storing the color of a pixels, ready to be rendered on our emulated window.

    @newpage\

    @section (label=sec:virtual-window) Creating a Virtual Window\

    The next step we need to take is displaying these pixels in a window, which will require a graphics library.
    What I considered at first was using **plain OpenGL**, which would have been a good excuse to finally learn how to use it. However, OpenGL is built around rendering using **vertices and polygons**. What I thought would be a better approach is to edit individual pixels instead, as we are currently doing with the LCD byte array.
    I found out that **SDL** makes this possible, thanks to a low-level API that gives us direct access to the pixel array that will be rendered on screen. For this project, I am using the latest SDL version at the time I am writing this paper, which is **SDL 3.2.10**.

    @subsection (label=subsec:cpu-window-implementation) CPU Window Implementation\

    At first, I just needed to check if the copyright symbol was showing up correctly and progressively scrolling from the top to the center of the screen. Thus, for now, a very inefficient, non-hardware-accelerated implementation was good enough.

    @code (language=C++, label=lst:sdl-initialization) code/sdl-init.code\

    At the very start of the **main** method we initialize SDL and create a 160x144 window.

    @newpage\

    Then, in the while loop, we update the window surface when V-Blank mode is entered.

    @code (language=C++, label=lst:cpu-window-implementation) code/cpu-window.code\

    And, as you can see in @ref fig:first-window\, we got our first window.

    @figure (H) {
        @graphic images/first-window.png\
        @centering\
        @caption First window\
        @label fig:first-window\
    }

    Problematically though, our window (the Game Boy display) is too small for modern displays.
    On my 1920x1080 display, it was barely even visible. There is no doubt we need to implement a way to **scale** the window up.

    @subsection (label=subsec:hardware-accelerated-window) GPU-Accelerated Window\

    This kind of task sounds like the perfect job for the GPU, though. So, I started working on a fully GPU-based implementation using the **CUDA library**.
    This library is made by NVIDIA and provides an API that lets us write **kernels**, which will be executed in parallel on the GPU.
    Of course, CUDA can only compile for NVIDIA graphics card.
    Luckily, I had already gained some experience with it during my last Physics Simulation project.
    \\
    Below, I will attach the **final CUDA code**, divided into different sections based on their purpose, along with a brief description of their use.\\

    @code (language=C++, label=lst:cuda-init) code/cuda-init.code\

    When setting up the structures for the emulator, we also prepare the CUDA pointers for arrays that reside on the graphics card.
    Specifically, we allocate memory for @latex { \textbf{device\_video} } --which will receive a copy of the byte array from the LCD class--and for @latex { \textbf{device\_scaled\_video} } --which will eventually be copied into the Uint32 SDL pixel array.

    @newpage\

    @code (language=C++, label=lst:cuda-kernel) code/cuda-kernel.code\

    Of course, these pointers can only be accessed by the GPU. We will create a kernel to manipulate them that is executed $(width $$dot$$ height) $$dot$$ scale^2$ times in parallel.\\
    If you are not familiar with how CUDA works, a kernel is launched by the @latex { \textbf{build\_video} } method.
    Before launching the kernel, we copy the video buffer to the GPU using **cudaMemcpy**, specifying that the copy direction is from host to device with the **cudaMemcpyHostToDevice** flag.
    The kernel @latex { \textbf{cuda\_build\_video} } is then launched with @latex { $width \times height$ } blocks and @latex { $scale \times scale$ } threads. Each block ID determines the original pixel position in the **video** buffer, while each thread ID determines the scaled position for that pixel. This way, each pixel from the original buffer is expanded into a $scale^2$ region in the output.
    
    \\A small example is shown in Figure @ref fig:scale-explanation\, illustrating a scale factor of 2.

    @figure (H) {
        @graphic (width=1$$textwidth$$) images/scale-explanation.png\
        @centering\
        @caption Scale explanation\
        @latex {
            \smallskip
            \small
            \textit{white pixels are shaded gray for visibility}
        }
        @label fig:scale-explanation\
    }

    Finally, the final buffer @latex { \textbf{device\_scaled\_video} } is copied directly into SDL's pixel buffer, which is done by specifying that the copy direction is from device to host using the **cudaMemcpyDeviceToHost** flag.

    @newpage\

    @code (language=C++, label=lst:cuda-colors) code/cuda-colors.code\

    The last thing we have to discuss is the @latex { \textbf{color\_to\_rgb} } method, which this time returns the original 4 shades of gray, with the help of the **mapRGB** method, which just packs the values **r**, **g** and **b** into a 32 bits value.
    \\
    And now, the window appears as shown below with a **scale factor of 10**.

    @figure (H) {
        @graphic (width=0.6$$textwidth$$) images/scaled-window.png\
        @centering\
        @caption Scaled window\
        @label fig:scaled-window\
    }

    It goes without saying that this GPU-based approach is significantly more efficient than the earlier CPU-only implementation.

    @section (label=sec:emulating-cartridge) Emulating the Game Cartridge\

    Now that have overcome yet another obstacle, it is time to complete our boot ROM emulation.
    As previously noted in @ref subsec:boot-analysis\, the last barrier to the boot process was the "NINTENDO" logo comparison between a version stored inside the boot ROM and one stored inside the **game ROM**.
    It should be clear by now that, in order to proceed further and eventually run actual games, we must emulate the game cartridge.
    \\
    Before implementing this, it is necessary to understand how game cartridges are structured and accessed.

    @subsection (label=sec:cartridge) Cartridge\

    We recall from @ref subsec:memory-mapping\ $$fs$$ that cartridge data is accessed through memory addresses ranging from **0x0000** to **0x7FFF**.
    We also remember that this data is split into **two** **16Kb banks**, with the second one being marked as **switchable**.
    It is fascinating to know that some cartridges did not only contain the ROM banks with the game code (as I originally thought), but could also supply additional components, such as SRAMs (Static Random-Access Memory) or a battery to preserve save data.
    Going back to the **two** banks, due to Game Boy address bus limitations, only **32 Kb** of memory could be accessed at a time.
    Problematically though, 32 Kb of game memory was not enough for most of the games available on Game Boy, if we think that a game does not only have its code to store, but also graphics tiles, audio tables and other data needed for the game.
    This problem was addressed using **Memory Bank Controllers** (MBCs)--hardware that enabled switching between different **ROM regions**.
    However, these additional components are not supported on my emulator, since the original Tetris DMG cartridge just included a 32 Kb ROM.
    
    @subsection (label=subsec:cartridge-structure) Structure\

    Despite these differences in hardware, all Game Boy cartridges conform to a standardized structure:

    @list {
        @item {
            The region from 0x0000 to 0x00FF typically includes interrupt handlers and other startup routines.
        }
        @item {
            The range 0x0100 to 0x014F contains the cartridge header, which stores metadata about the game.
        }
        @item {
            The remaining memory contains the actual game code and data.
        }
    }

    @subsection (label=subsec:game-cartridge-implementation) Implementation\

    In my Emulator, file paths are actually hard-coded.
    At startup, the program specifically looks for files named @latex { \textbf{dmg\_boot.bin} } and **tetris.gb**.

    \\
    @latex {
        \lstinline!cpu.load_bootup("dmg_boot.bin", mem);!
        \\
        \lstinline!cpu.load_rom("tetris.gb", mem);!
    }
    \\

    We have already covered how @latex { \textbf{load\_bootup} } works.
    What remains is the implementation of @latex { \textbf{load\_rom} }.

    @code (language=C++, label=lst:game-load) code/game-load.code\

    One important detail here is that we cannot just read the **.gb** file and copy its content inside the **Memory** structure. Doing so would overwrite the boot ROM, specifically the first **256 bytes** used during the boot sequence.
    What we are doing instead is to only copy the data starting from address **0x100**, while to temporarily store the first bytes inside a buffer. Once the boot ROM has finished executing, we then copy those initial bytes into memory to complete the emulation of the cartridge.

    @subsection (label=subsec:debugging-changes) How the Debugging Process Changed\

    When transitioning to running Tetris on the emulator, I realized that disassembling the entire ROM manually would have been far too time-consuming. While I still aimed to understand the program flow and verify how the emulator behaved, I decided to rely on this existing @href https://github.com/osnr/tetris/ disassembled version of Tetris\.
    \\
    This shift allowed me to stay focused on debugging and improving the emulator itself rather than investing excessive time deciphering game code. The disassembly served as a valuable reference, helping me interpret instructions and memory interactions more efficiently while still enabling a hands-on learning experience.

    @newpage\

    @section (label=subsec:first-tetris-run) First Tetris Execution\

    At this point, I wanted to try executing the game for the first time, even though I knew there were still many features left to implement. As expected, after finally seeing our window with the whole Nintendo logo, running Tetris at this stage results in a completely white screen.

    @figure (H) {
        @graphic (width=0.6$$textwidth$$) images/logo.png\
        @centering\
        @caption Final logo\
        @label fig:final-logo\
    }

    It was finally time to analyze the disassembly. That is when I noticed that Tetris checks if all the arrow keys are down at the same time and, if it is the case, a reset occurs. Thus, the next thing to add is the joypad emulation.

    @code (language=Asm, label=lst:buttons-check) code/buttons-check.code\

    What initially confused me was why the game assumed buttons were being pressed, even though I had not implemented input handling yet.

    \\ \\
    among other initialization instructions from **0x0199** to **0x02C2**, something called "DMA transfer" was being executed.
    This reveals our first issue: we still have not implemented one of the most important features on the Game Boy.

    // TODO: put later (DMA), resetting problem here

    @section (label=sec:joypad) Joypad Emulation\

    The Game Boy features a simple input scheme: four directional buttons and four action buttons â€” A, B, Select, and Start.

    @subsection (label=subsec:joypad-register) Joypad Register\

    Games can access inputs through a register located at memory address **0xFF00**.
    Buttons were interestingly arranged as a **2x4 matrix**.

    @latex {
        \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | c | c | c | c | }
            \toprule
            7 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
            \midrule
            & \makecell{Select\\buttons} & \makecell{Select\\d-pad} & \makecell{Start /\\Down} & \makecell{Select /\\Up} & \makecell{B /\\Left} & \makecell{A /\\Right} \\
            \midrule
        \end{tabular}

        \caption{Joypad flags}
        \end{table}
    }

    @list {
        @item {
            Select buttons: When this bit is 0, the state of the Start, Select, B, and A buttons can be read from the lower 4 bits.
        }
        @item {
            Select d-pad: When this bit is 0, the state of the directional (D-pad) keys is available in the lower 4 bits.
        }
        @item {
            The lower 4 bits are read-only. **Notably**, unlike most of the Game Boy's conventions, **a pressed button is represented by a 0**, not a 1.
        }
    }

    Personally, I do not see why the controls could not have been arranged as a simple 1x8 matrix. I assume there must have been a specific reason why the designers opted for this layout instead.

    @section (label=sec:credits-scene) The Credits Scene\

    @section (label=sec:dma) DMA\

    Direct Memory Access (DMA) is a process by which bytes from a specified memory region are copied by hardware into another region, instead of relying on copying with software. On the Game Boy, the destination of this transfer is always the Object Attribute Memory (OAM).
    This approach is significantly faster than copying data through software, although it comes with certain hardware limitations, as we will see.

    @subsection (label=subsec:dma-control-register) DMA Control Register\

    Writing to the DMA control register, located at **0xFF46**, initiates a DMA transfer.
    The value written to this register determines the **source address**, and the **destination** is always fixed:
    \\
    @latex {
        \lstinline!Source*: 0xXX00 - 0xXX9F! \\
        \lstinline!Destination: 0xFE00 - 0xFE9F! \\
        \lstinline!*(XX) is the value inside the register! \\
    }
    \\

    After writing to the register, a delay of **4 clock cycles** occurs. Then, one byte is transferred every 4 clock cycles, for a total duration of **640 clock cycles**, plus the initial 4-cycle delay, totaling **644 clock cycles**.

    @subsection (label=subsec:dma-bus-conflict) DMA Bus Conflicts\

    Although DMA is highly efficient, it introduces a key limitation.
    While DMA is transferring bytes, the **data buses** used to access RAM and ROM become unavailable, effectively **stalling the CPU**.
    Fortunately, **High RAM** is not affected by this restriction. Hence, games usually would copy small routines into this region that simply wait for the DMA transfer to complete.

    @newpage\

    @subsection (label=subsec:tetris-dma) DMA Transfers in Tetris\

    That is exactly what Tetris is doing. \\
    First, during game initialization, a routine of **12 bytes** at region **0x2A7F** - **0x2A8A** is copied to region **0xFFB6** - **0xFFC1**.
    \\
    This routine will write to 0xFF46 (DMA control register) to copy bytes from **0xC000** - **0xC09F** to **0xFE00** - **0xFE9F** and wait for **DMA to complete**.

    @code (language=Asm, label=lst:dma-copy) code/dma-copy.code\

    Then this routine will be called **once** at first an then once every time a VBlank interrupt is called.

    @code (language=Asm, label=lst:dma-vblank) code/dma-vblank.code\
}